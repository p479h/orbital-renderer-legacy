try:
    import mathutils;
except:
    print("Could not import mathutuils");
try:
    import bpy;
except:
    None;
from PointGroup import PointGroup
from skimage import measure
from isosurf import Isosurface
from Bobject import *
from FileManager import FileManager as fm
import numpy as np;
import os;
import json;
import re;

    
def load_atoms_data(): 
    with open("atoms.json", "r") as j_file:
        return json.load(j_file);

    

class Atom(Bobject):
    #Defining some data relevant for this class
    data = load_atoms_data();
    radii_list = data["radii"];
    colors = data["atoms"];
    material_dict = {}
    
    # The color and radii will be stored by the class for compatibility with old projects!
    def __init__(self, position = None, radius = None, material = None, name = None):
        """
            position: 1x3 matrix  with cartesian coordinates of the center of the atom
            radius: float with radius of the atom
            material: blender object with the material of the atom
            """
        super().__init__();
        self.name = self._set_name(name);
        self.position = self._set_position(position);
        self.radius = self._set_radius(radius);
        self.material = self.set_material(material);

    def set(self, argument, attribute): #I did this in case at some point we wish to add underscores or some other prefix to property names
        #This makes it possible to specify the positions and such at a later stage after the creation of the atom
        setattr(self, attribute, argument);


    def _set_name(self, name):
        self.set(name, "name");
        return self.name;

    def _set_position(self, position):
        if type(position) == type(None):
            return None;
        self.set(position, "position");
        self.position = np.array(list(position));
        return self.position;

    def _set_radius(self, radius):
        self.set(radius, "radius");
        if not self.radius:
            if self.name:
                self.radius = self.radii_list[self.name];
        return self.radius;

    def set_material(self, material):
        self.set(material, "material");
        if not self.material:
            if self.name:
                self.material = self.make_material(self.name);
        return self.material;


    def make_material(cls, A):
        """A is the atom name. Each one has a different color"""
        if not bpy.data.materials.get(A):
            #Note that these colors were not generated by hand. That would have been suicide;
            m = bpy.data.materials.new(name=A);
            m.use_nodes = True;
            color = cls.hex2rgb(cls.colors[A], _tuple=True)
            m.node_tree.nodes["Principled BSDF"].inputs[0].default_value = color;
            m.node_tree.nodes["Principled BSDF"].inputs[7].default_value = .1;
        else:
            m = bpy.data.materials.get(A);
        return m;

    def make_orbital_material(self, sign, copy = True, ivo = False):
        A = {"p":"positive", "n": "negative"}[sign]
        try:
            bpy.data.materials.get(A)#So we can use this class without being in 
        except:
            None
        if not bpy.data.materials.get(A) or not copy:
            m = bpy.data.materials.new(name=A);
            m.use_nodes = True;
            if A == "positive":
                rgb = (.16, .47, .8, 1)
                if ivo:
                    rgb = (0.05, 0.24, 0.91, 1)
            else:
                rgb = (.8, .33, .11, 1)
                if ivo:
                    (0.1, 0.419, 0.07, 1)
            
            m.node_tree.nodes["Principled BSDF"].inputs[0].default_value = rgb;
            if bpy.data.scenes["Scene"].render.engine == "BLENDER_EEVEE":
                m.node_tree.nodes["Principled BSDF"].inputs[5].default_value = .3;
            m.node_tree.nodes["Principled BSDF"].inputs[7].default_value = .1;
            m.node_tree.nodes["Principled BSDF"].inputs[14].default_value = 1;
            m.node_tree.nodes["Principled BSDF"].inputs[15].default_value = .5;
            m.node_tree.nodes["Principled BSDF"].inputs[16].default_value = .5;
            m.use_screen_refraction= True
            m.blend_method = "BLEND"
            m.show_transparent_back = False
        else:
            m = bpy.data.materials.get(A);
        return m;

    def draw(self, smooth = False, modifier = False):
        bpy.ops.mesh.primitive_ico_sphere_add(radius=self.radius, location=self.position);
        obj = bpy.context.active_object;
        if not self.find_material(self.name):
            self.make_material(self.name)
        obj.active_material = self.find_material(self.name);
        obj.name = self.name
        self.set_obj(obj)

        if smooth or modifier:
            self.smooth(modifier = modifier)

class Bond(Atom):
    def __init__(self,obj):
        super().__init__()
        self.set_obj(obj)
    
    
        
class Molecule(Atom):
    """
        This class unites many atoms, allowing them to bond and be rendered together
        Here each atom becomes associated to an index in the arrays with info about the molecule"""

    def __init__(self, atoms, radius_factor = 1,connections = None, name = None,
                 prettify_radii = True, collection = None, orders = []):
        super().__init__();
        self.atoms = atoms;
        self.prettify_radii = prettify_radii; #If turned off, the actuall atomic radii will be used
        self.position = self.get_positions(atoms); #Note how we use the same property name for Atoms and Molecule. This is because then we can rely on the "setters" already defined in Atoms.
        self.radius = self.get_radii(atoms)*radius_factor;
        self.material = self.get_materials(atoms);
        self.names = self.set_names(atoms); #names of all atoms in the same order as positions.
        self.name = self.set_molecule_name(name); #Name of the molecule
        self.connections = connections; # Bond indices
        self.meshes = []; #All of this molecules meshes
        self.atom_meshes = [];
        self.bond_meshes = [];
        self.bonds = [];
        self.bond_radii = [];
        self.bond_orders = orders; #The order of the bonds!
        self.mules = []; #Used for the animations
        self.collection = self.make_collection(collection); #Make collection belongs to Bobject class
        self.bond_collection = self.make_collection(self.collection, "bonds_"+name) #If we don't add "name", collections with the same name will be created. Since blender does not allow for this, we end up re-referencing exisint collecitons. Not GUT for multiple molecules
        self.atom_collection = self.make_collection(self.collection, "atoms_"+name)
        self.orbital_collection=  self.make_collection(self.collection, "orbitals_"+name)
        self.outline_materials = []; #Materials used for cartoonish style 
        self.orbital_indices = np.array([0 for i in range(len(self.position))]).astype(bool);
        self.orbital_meshes = [None for i in range(len(self.position))]; #Meshes of molecular orbitals
        self.orbital_matrices = np.tile(np.eye(4), (len(self.position), 1, 1)); #Matrices of molecular orbitals
        self.orbital_names = [None for i in range(len(self.position))];
        self.orbital_kinds = [None for i in range(len(self.position))];
        
    
    def translate(self, v):
        """
            Translates the molecule by v"""
        if hasattr(self, "mule"):
            if type(v) == float or type(v) == int:
                v = [v]*3
            self.translate_obj(self.mule, v)
        else:
            self.position += v;
        return self

    def scale(self, v):
        """
            scales the molecule by v"""
        if hasattr(self, "mule"):
            self.scale_obj(self.mule, v)
        else:
            self.position*=v;
        return self

    def rotate(self, angle, axis = [0, 0, 1]):
        """
            rotates the molecule by angle about axis
            if using quaternion, angle should be a float or int.
            if using Euler, angle should be a tuple or list."""
        if hasattr(self, "mule"):
            self.rotate_obj(self.mule, angle, axis)
        else:
            #We apply the rotation to the atoms directly
            rotMat = np.array(
                mathutils.Matrix.Rotation(angle, 3, axis)
                )
            self.position = np.einsum('bc,ac->ab', rotMat, self.position)
        return self
        
    def scale_atoms(self, v, atoms = None):
        if atoms is None:
            atoms = np.ones(len(self.names))
        for i, a in enumerate(self.atoms):
            if not atoms[i]:
                continue
            a.scale(v)
        return self
    
    def translate_bond_orders(self, v, bonds = None):
        if bonds is None:
            bonds = np.ones(len(self.names))
        for i, b in enumerate(self.bonds):
            if not bonds[i]:
                continue
            b.translate(v)
        return self
    
    def rotate_bonds(self, angles, axes = [0, 0, 1], bonds = None):
        if bonds is None:
            bonds = np.ones(len(self.names))
        if type(angles) in (int, float):
            angles = np.ones(len(self.atoms))*angles
        axes = np.array(axes)
        if axes.ndim == 1:
            axes = np.tile(axes, (len(self.atoms), 1))
        for (i, b), angle, axis in zip(enumerate(self.bonds), angles, axes):
            if not bonds[i]:
                continue
            b.rotate(angle, axis)
        return self


    def scale_bonds(self, v, bonds = None):
        if bonds is None:
            bonds = np.ones(len(self.names))
        for i, b in enumerate(self.bonds):
            if not bonds[i]:
                continue
            b.scale(v)
        return self
    
    def translate_atoms(self, v, atoms = None):
        if atoms is None:
            atoms = np.ones(len(self.names))
        for i, a in enumerate(self.atoms):
            if not atoms[i]:
                continue
            a.translate(v)
        return self
    
    def rotate_atoms(self, angle, axis = [0, 0, 1], atoms = None):
        if atoms is None:
            atoms = np.ones(len(self.names))
        for i, a in enumerate(self.atoms):
            if not atoms[i]:
                continue
            a.rotate(angle, axis)
        return self

    def set_scale_atoms(self, v, atoms = None):
        if atoms is None:
            atoms = np.ones(len(self.names))
        for i, a in enumerate(self.atoms):
            if not atoms[i]:
                continue
            a.set_scale(v)
        return self
    
    def set_position_atoms(self, v, atoms = None):
        if atoms is None:
            atoms = np.ones(len(self.names))
        if type(v) in (int, float):
            v = [v]*3
        v = np.array(v)
        if v.ndim == 1: # If we only supply one coordinate
            v = np.tile(v, (len(self.atoms), 1))
        for (i, a), p in zip(enumerate(self.atoms), v):
            if not atoms[i]:
                continue
            a.set_position(p)
        return self
    
    def set_rotation_atoms(self, angles, axes = [0, 0, 1], atoms = None):
        if atoms is None:
            atoms = np.ones(len(self.names))
        if type(angles) in (int, float):
            angles = np.ones(len(self.atoms))*angles
        axes = np.array(axes)
        if axes.ndim == 1:
            axes = np.tile(axes, (len(self.atoms), 1))
        for (i, a), angle, axis in zip(enumerate(self.atoms), angles, axes):
            if not atoms[i]:
                continue
            if type(angle) in (np.float64, np.float32, np.float16, np.int64, np.int32, np.int16):
                angle = float(angle)
            a.set_rotation(angle, axis)
        return self
    
    def set_scale_bonds(self, v, bonds = None):
        if bonds is None:
            bonds = np.ones(len(self.names))
        for i, b in enumerate(self.bonds):
            if not bonds[i]:
                continue
            b.set_scale(v)
        return self
    
    def set_position_bonds(self, v, bonds = None):
        if bonds is None:
            bonds = np.ones(len(self.names))
        if type(v) in (int, float):
            v = [v]*3
        v = np.array(v)
        if v.ndim == 1: # If we only supply one coordinate
            v = np.tile(v, (len(self.bonds), 1))
        for (i, b), p in zip(enumerate(self.bonds), v):
            if not bonds[i]:
                continue
            b.set_position(p)
        return self
    
    def set_rotation_bonds(self, angles, axes = [0, 0, 1], bonds = None):
        if bonds is None:
            bonds = np.ones(len(self.names))
        if type(angles) in (int, float):
            angles = np.ones(len(self.bonds))*angles
        axes = np.array(axes)
        if axes.ndim == 1:
            axes = np.tile(axes, (len(self.bonds), 1))
        for (i, b), angle, axis in zip(enumerate(self.bonds), angles, axes):
            if not bonds[i]:
                continue
            if type(angle) in (np.float64, np.float32, np.float16, np.int64, np.int32, np.int16):
                angle = float(angle)
            b.set_rotation(angle, axis)
        return self

    def to_quaternion_atoms(self):
        for a in self.atoms:
            a.to_euler()

    def to_euler_atoms(self):
        for a in self.atoms:
            a.to_quaternion()

    def to_quaternion_bonds(self):
        for b in self.bonds:
            b.to_quaternion()
            
    def to_euler_bonds(self):
        for b in self.bonds:
            b.to_euler()
    

    def cartoonify(self, edgewidth = 0.03):
        """
            Makes several PERMANENT changes such tha the molecule (when rendered with EEVEE), look cartoonish.
            """
        self.outline_materials.append(self.make_outline_material()) # Make the dark outline. The reason we make a copy of the original is because some bonds do not have 2 materials.
        for m in self.material:
            m.node_tree.nodes["Principled BSDF"].inputs[5].default_value = 0.02; #Set the specular to a low value, as that looks weird in EEVEE
            
        for mesh_list in [self.atom_meshes, self.bond_meshes]:
            self.deselect_all();# Deselect everything
            self.select(*mesh_list); # Select the set of objects in question
            self.set_active(mesh_list[0]);
            bpy.ops.object.modifier_add(type = "SOLIDIFY");
            mesh_list[0].modifiers["Solidify"].thickness = edgewidth;
            mesh_list[0].modifiers["Solidify"].offset = 0;
            mesh_list[0].modifiers["Solidify"].material_offset = 2;
            mesh_list[0].modifiers["Solidify"].use_flip_normals = True;
            bpy.ops.object.make_links_data(type="MODIFIERS");
            for ob in mesh_list:
                for m in self.outline_materials:
                    ob.data.materials.append(m);            


    @staticmethod
    def find_normal_from_points(center, corners):
        """
            Center 1x3 array with the coordinates of the center of the figure (center of the double bond)
            corners nx3 array with the coordinates of the edges of the figure (all atoms connected to the double bond and all those connected to these atoms. (0th and 1st gen cousins of the double bond)
            returns 1x3 array with "average" normal. To the plane formed by these points.
            Note this can only be used if there is more than 1 corner!!!!
            """
        r = (center - corners)/np.linalg.norm(center-corners, keepdims = True, axis = 1);
        normals = np.array([np.cross(r[0], r[i]) for i in range(2, len(r))]);
        dots = np.array([np.dot(normals[0], n) for n in normals]);
        normals[dots<0]*=-1; #Invert antiparallel.
        avg_norm = np.sum(normals, axis = 0)/np.sqrt(len(normals))
        return avg_norm
        

    def make_higher_order_bond(self, bond_index, atom_pair_indices, neighbour_indices = [], order = 2):
        """
            bond_index: int with the index of the single bond which is to be doubled
            atom_pair_indices: list (0,2) int indices of atoms which form the bond
            neighbour_indices: list (0,N) int indices of 1st gen neighbouts to atom_pair_indices
            """
        c = self.bond_meshes[bond_index];
        scale = .55 if len(neighbour_indices) == 2 else 0.4;
        self.scale_obj(c, [scale, scale, 1]);
        self.apply_transform(c, scale = True)
        cmat = np.array(c.matrix_world); #The unit vectors present here need to be used later.
        rad = self.bond_radii[bond_index];
        d = rad/2.1
        if len(neighbour_indices) < 2:
            r = np.array(cmat[:3, 0]);
            r = r/np.linalg.norm(r);
        else:
            r_center = np.mean(self.position[atom_pair_indices, :], axis = 0)
            r_neighbours = self.position[np.r_[atom_pair_indices,neighbour_indices], :]
            normal = self.find_normal_from_points(r_center, r_neighbours)
            r = np.array(cmat[:3, 2]);
            r = r/np.linalg.norm(r);
            r = np.cross(normal, r); #Now we have a vector that points perpendicular to the bonding axis!
        c_copy = c.copy();
        if order == 3:
            c_copy2 = c.copy();
            self.link_obj(c_copy2, self.collection);
            r*=1.8;
        c.matrix_world = mathutils.Matrix.Translation(r*d)@c.matrix_world;
        c_copy.matrix_world = mathutils.Matrix.Translation(-r*d)@c_copy.matrix_world;
        self.link_obj(c_copy, self.collection)
        self.deselect_all()
        self.select(c, c_copy)
        if order == 3:
            self.select(c, c_copy, c_copy2);
        self.set_active(c)
        bpy.ops.object.join();#The double bond now occupies the same slot as the former single bond.
        bpy.ops.object.transform_apply(scale = True, location = False, rotation = False);

        #Now we set the correct origin
        self.set_origin(c);

    def find_neighbours(self, pair):
        connections = np.array(self.connections)
        pair = np.array(pair)
        contains_connections = {*connections[np.any(pair[:, np.newaxis, np.newaxis] == connections, axis = (0,2)), :].flatten()}
        return np.array(list({*contains_connections}-{*pair}))

    
    def find_static_atoms(self, matrix, tol = 2e-1): # Lower tolerances require better xyz files... But this is good enough for most purpuses
        new_positions = (matrix@self.position.T).T
        r = np.linalg.norm(self.position - new_positions, axis = 1, keepdims = False)
        return r<tol #Returns logical array indexing atoms that do not get out of place during symmtry operation

    def find_static_orbitals(self, matrix, tol = 2e-1):
        static_atoms = self.find_static_atoms(matrix, tol).astype(bool);
        return static_atoms&(self.orbital_indices!=-1)&(np.array(self.orbital_meshes)!=None) #Returns logical array indexing orbitals that do not get out of place during symmtry operation

    def find_final_projections(self, mat, orb = "pz", tol = 2e-1):
        """
            Finds the coefficients that multiply the size of the molecular orbitals based on their orientation after the tranformation relative to before
            This funcition is more important for pxyz than s orbitals
            For example:
                if a transformation rotates a px orbital about the y axis 90 degrees, we get 0 in the end, since there is no overlap with itself anymore
                if a transformation rotates a pz orbital about the z axis, the result will always be 1
                if a transformation rotates a py orbital about the x axis 60 degress, you get an overlap of 0.5. Here I neglect the sign because this will be used for scaling the orbital, which will be rotated already by the animation.
            """
        remaining = self.find_static_atoms(mat, tol)
        if orb in ("2s", "s"):
            return remaining.astype(int)
        if mat.shape[-1] == 3:
            eye = np.eye(4);
            eye[:3, :3] = mat[:,:];
            mat = eye;
        final_orientations = np.einsum('ij,kjl->kil',mat,self.orbital_matrices);
        projection = (self.orbital_matrices*final_orientations).sum(axis = 1)[:,{"px":0, "x":0,"py":1, "y":1,"pz":2, "z":2}[orb]]
        return remaining*projection #We multiply by remaining because the orbitals that leave their atoms must be set to 0
    
        
    def add_mesh(self, verts, faces, sign = "p", offset = [0, 0, 0], scale = 1): #p is "positive"
        """
            makes a mesh from verts and faces"""
        bpy.ops.object.select_all(action='DESELECT')
        new_mesh = bpy.data.meshes.new("MO"+str(len(self.orbital_meshes)));
        new_mesh.from_pydata((verts*scale+offset).tolist(), [], faces.tolist());
        new_mesh.update()
        new_object = bpy.data.objects.new('Orbital', new_mesh)
        self.orbital_collection.objects.link(new_object)
        new_object.select_set(True)
        bpy.context.view_layer.objects.active = new_object
        bpy.ops.object.shade_smooth()
        self.set_origin(new_object);
        return new_object;

    def generate_isosurface(self, scalarfield, grid, isovalue, material_copy = True, center_origin = True):
        """
        Applies the marching cubes algorithm to scalarfield with many atoms' vector fields added
        scalarfield: values of wavefunction in the corresponding places in the grid
        grid: (natoms, n, n, n, 3) array with the positions where the wavefunction is evaluated
        isovalue: float with the value where the isosurface is constructed
        material_copy: boolean specifying if every orbital will have it's own instance of the material
        """
        self.deselect_all()
        pair = []
        r = grid.max();
        n = len(grid);
        spacing = np.full(3, r*2/(n-1));
        for sign, val in zip(["p", "n"],[1, -1]):
            isovalue*=val;
            try:
                vertices, faces, normals, values = measure.marching_cubes(scalarfield, level = isovalue, spacing = spacing)
            except: #If the isovalue is too high/low to begin with:
                vertices = np.array([[0, 0, 0]]);
                normals = np.array([]);
                faces = np.array([]);
                values = np.array([]);
            orb = self.add_mesh(vertices - r, faces, sign)
            orb.active_material = self.make_orbital_material(sign, copy = material_copy);    
            pair.append(orb)
        self.select(*pair)
        self.set_active(orb)
        bpy.ops.object.join();
        self.set_origin(orb);
        return orb

    def make_orbital(self, scalarfield, grid, isovalue, material_copy = True, center_origin = True, MO = True, join = True):
        """
        Applies the marching cubes algorithm to scalarfield with many atoms' vector fields added
        scalarfield: values of wavefunction in the corresponding places in the grid
        grid: (natoms, n, n, n, 3) array with the positions where the wavefunction is evaluated
        isovalue: float with the value where the isosurface is constructed
        material_copy: boolean specifying if every orbital will have it's own instance of the material
        join: boolean specifying if both positive and negative lobes are joined 
        """
        if MO:
            scalarfields = scalarfield.sum(0, keepdims = True)
        else:
            scalarfields = scalarfield.copy();
        orbs = [];
        self.deselect_all()
        for scalarfield in scalarfields:
            orb = self.generate_isosurface(scalarfield, grid, isovalue, material_copy, center_origin);
            orbs.append(orb);
        self.select(*orbs)
        self.set_active(orb);
        if join:
            bpy.ops.object.join();
        if center_origin:
            self.set_origin(orb);
        if join:
            return orb;
        return orbs;

    def make_atomic_orbital(self, position, isovalue, orbital_func, r, n = 60, orbital_orientation_function = lambda a: np.eye(3), atom_index = None, **kwargs):
        """
            Makes an atomic orbital at specified position
            if atom_index is provided, data is incorporated into the object and it can be animated.
            """
        grid = Isosurface.generate_grid(r, n)
        scalarfield = Isosurface.apply_field(grid, 
            np.zeros((1, 3)), 
            orbital_func, 
            SALC = [1],
            orbital_orientation_function = orbital_orientation_function)
        orb = self.make_orbital(scalarfield, grid, isovalue, **kwargs);
        orb.location = position
        if type(atom_index) == int:
            self.set_parent(self.atom_meshes[atom_index], orb)
            self.orbital_meshes[atom_index] = orb
            self.meshes.append(orb)
            self.orbital_names[atom_index] = "Not None"
        return orb
    
    def make_atomic_orbitals(self, isovalue, orbital_func, r=4, n = 60, coeffs = [], scale = 1, **kwargs):
        """
            Adds an atomic orbital to the mesh for each orbital where coeff in coeffs != 0
            """
        if len(coeffs) == 0:
            coeffs = np.ones(len(self.position))
        orbs = []
        for i, p in enumerate(self.position):
            if coeffs[i] == 0: continue
            orb = self.make_atomic_orbital(p, isovalue, orbital_func, r, n, atom_index = i, MO = False, **kwargs);
            orb.scale = [scale*coeffs[i]/abs(coeffs[i])]*3
            self.set_active(orb)
            bpy.ops.object.transform_apply(location = False, rotation = False, scale = True)
            orbs.append(orb)
        return orbs

    def erase_MO(self, MO): #MO is the mesh of the orbital
        index = self.orbital_meshes.index(MO)
        self.orbital_meshes[index] = None
        self.orbital_names[index] = None
        self.orbital_matrices[index, :, :] = np.eye(4)
        self.orbital_indices[index] = False
        index = self.meshes.index(MO)
        self.meshes.pop(index)
        bpy.data.objects.remove(MO, do_unlink=True)

    def erase_MOS(self):
        for MO in [o for o in self.orbital_meshes if o]: #Without this list comprehension the loop breaks prematurely!
            self.erase_MO(MO)

    def erase(self):
        for obj in self.meshes+self.mules:
            self.delete_obj(obj);
        self.meshes = []
        self.mules = []

    def set_names(self, atoms):
        self.names = [a.name for a in atoms];
        return self.names;
    
    def set_molecule_name(self, name):
        if name:
            self.name = name;
            return name;
        self.name = "".join(self.names);
        return self.name;

    def get_positions(self, atoms):
        return np.array([a.position for a in atoms]);

    def get_radii(self, atoms):
        return np.array([a.radius for a in atoms]);

    def get_materials(self, atoms):
        return [a.material for a in atoms];

    @staticmethod
    def load_molecule_data(filepath):
        return fm.load_molecule_data(filepath)
    
    @staticmethod
    def dump_molecule_data(data, filepath):
        fm.dump_molecule_data(data, filepath)
        

    #Now onto the rendering part
    def getBondRadius(self, rad):
        r = rad.mean()/2.3;
        if any(r > rad/2):
            r = min(rad)/2;
        return r;

    @classmethod
    def from_file(cls, path, *args, **kwargs):
        if "name" not in kwargs:
            kwargs["name"] = os.path.splitext(os.path.basename(path))[0]
        if path.endswith(".xyz"):
            return cls.from_xyz_file(path, *args, **kwargs)
        elif path.endswith(".mol"):
            return cls.from_mol_file(path, *args, **kwargs)
        elif path.endswith(".smol"):
            return cls.from_smol_file(path, *args, **kwargs)
        else:
            print("File type not suported")
            print("Supported file types are: ")
            print("xyz\nmol\nsmol")

    #Following functions have been made accessible from Molecule class but belong elsewhere.
    @classmethod
    def read_smol(cls, path):
        return fm.read_smol(path)
    
    @classmethod
    def read_xyz(cls, path):
        return fm.read_xyz(path)

    @classmethod
    def read_mol(cls, path):
        return fm.read_mol(path)
    
    @classmethod
    def from_smol_file(cls, path, *args, **kwargs):
        names, positions, bonds = cls.read_smol(path);
        atoms = [Atom(position = coord, name = name) for coord, name in zip(positions, names)];
        return cls(atoms, connections = bonds, *args, **kwargs);


    @classmethod
    def from_xyz_file(cls, path,*args, **kwargs):
        names, positions = cls.read_xyz(path);
        atoms = [Atom(position = coord, name = name) for coord, name in zip(positions, names)];
        return cls(atoms, connections = cls.detect_bonds_xyz(atoms), *args, **kwargs);

    @classmethod
    def from_mol_file(cls, path, *args, **kwargs):
        a, c, b, o = cls.read_mol(path)
        atoms = [Atom(position = coord, name = name) for coord, name in zip(c, a)];
        return cls(atoms, connections = b, orders = o, *args, **kwargs);

    def make_atom_meshes(self, smooth = True, prettify_radii = True):
        self.atom_meshes = [];
        rad = self.radius.copy();
        if prettify_radii:
            rad = self.get_smaller_radii(self.radius)
        for a, r in zip(self.atoms, rad):
            a._set_radius(r)
            a.draw(smooth = smooth, modifier = True)
            obj = a.get_obj()
            self.atom_meshes.append(obj);
            self.meshes.append(obj);
            self.unlink_obj(obj);
            self.link_obj(obj, self.atom_collection);
        return self.meshes
            
    def get_smaller_radii(self, radius, s = 0.70):
        rad=np.array(radius).copy();
        rad[rad>self.radii_list["Fe"]*s] = self.radii_list["Fe"]*s;
        rad[np.array(self.names) == "H"] = 0.25
        return rad;



    def make_cylinder_meshes(self, prettify_radii = True, cartoonish = False):
        if type(self.connections) == type(None):
            return;

        if prettify_radii:
            rad = self.get_smaller_radii(self.radius);
        else:
            rad = self.radius
        for connection in self.connections:
            i0, i1 = connection;
            p0, p1 = self.position[i0, :], self.position[i1, :];
            m0, m1 = self.material[i0], self.material[i1];
            r0, r1 = rad[i0], rad[i1];
            n0, n1 = self.names[i0], self.names[i1];
            r = self.getBondRadius(rad[np.array([i0, i1])]);
            p1p0 = (p1-p0)/np.linalg.norm(p1-p0);
            middle = (p1+p1p0*(r0-r1) + p0)/2;
            if self.names[i1] != self.names[i0]: #If they are different atoms we make half the bond of each color. Else we make a single long cyllinder
                if not cartoonish:
                    c0 = self.cylinder_between(*middle, *p0, r);
                    c1 = self.cylinder_between(*middle, *p1, r);
                else:
                    c0 = self.cylinder_between(*(middle - 0.0001*p1p0), *p0, r); # IF we are in cartoonish mode, the faces of the two different cylinders may overlap.
                    c1 = self.cylinder_between(*(middle + 0.0001*p1p0), *p1, r);
                self.smooth_obj(c0, modifier = False);
                c0.data.use_auto_smooth = True;
                self.smooth_obj(c1, modifier = False);
                c1.data.use_auto_smooth = True;
                c0.active_material = m0;
                c1.active_material = m1;
                self.select(c0);
                bpy.ops.object.join();
            else:#We make a single long bond
                c0 = self.cylinder_between(*p1, *p0, r);
                self.smooth_obj(c0, modifier = False);
                c0.data.use_auto_smooth = True;
                c0.active_material = m0;
            self.bond_radii.append(r);
            obj = bpy.context.active_object;
            obj.name = n0 + n1;
            self.bond_meshes.append(obj);
            self.meshes.append(obj);
            self.unlink_obj(obj)
            self.link_obj(obj, self.bond_collection)
            self.set_origin(obj)
            self.bonds.append(Bond(obj))
            


    def dieting(self, stick_factor, apply = True):
        for b in self.bond_meshes:
            self.scale_obj(b, [*[stick_factor]*2, 1]);
            self.apply_transform(b, scale = apply)
        for a in self.atom_meshes:
            self.scale_obj(a, [stick_factor]*3);
            self.apply_transform(a, scale = apply)


    
    def draw(self, mirror_options={}, rotation_axis_options={}, stick = False, mirror = True, rotation_axis = True, prettify_radii = True, show_double_bonds = True, cartoonish = False, stick_factor = 0.5):
        """
            Creates all the meshes.
            mirror_options and rotaiton_axis_options are the arguments that can be suppplied
            to the functions (respectively):
                bpy.ops.mesh.primitive_circle_add
                bpy.ops.mesh.primitive_cylinder_add
            supplied as a dictionary.
            stick means stick and ball model. It is used to give emphasis to the orbitals instead of atoms themselves
        """
        self.mule = self.make_empty()
        
        self.make_atom_meshes(prettify_radii = prettify_radii);
        self.make_cylinder_meshes(prettify_radii = prettify_radii, cartoonish = cartoonish);

        if show_double_bonds:
            for i, o in enumerate(self.bond_orders):
                if o == 1:
                    continue
                elif o < 4: #We can not have 4 bonds!!!
                    self.make_higher_order_bond(i, self.connections[i], self.find_neighbours(self.connections[i]), order = o);
                    
        if stick: #Stick has to come after show_double_bonds
            self.dieting(stick_factor, apply = True)
                
        if cartoonish:
            self.cartoonify(edgewidth = .02);
            self.switch_render_engine("BLENDER_EEVEE");

        #These are used for animations
        if not hasattr(self, "mule"):
            self.make_empty(True); # This objects parents the entire molecule. This way we can have unjoined meshes that all move together.
        else:
            self.deselect_all();
            self.select(*self.meshes);
            self.set_active(self.mule);
            bpy.ops.object.parent_set(type="OBJECT");
            
        #Note that the mirror and rotation axis are not parented as they would suffer deformations during the animations.
        if mirror:
            self.make_mirror(mirror_options, prettify_radii = prettify_radii);
            self.unlink_obj(self.mirror)
            self.link_obj(self.mirror, self.collection)
        if rotation_axis:
            self.make_rotation_axis(rotation_axis_options, prettify_radii = prettify_radii);
            self.unlink_obj(self.rotation_axis)
            self.link_obj(self.rotation_axis, self.collection)

    def draw_mpl(self, ax):
        for b in self.connections:
            ax.plot(*(self.position[np.array(b)]).T, c = "black");
            
        for a in set(self.names):
            indices = [i for i, n in enumerate(self.names) if n == a];
            points = np.array([self.position[i] for i in indices])
            color = self.colors[a];
            color = self.hex2rgb(color);
            radius = self.radii_list[a];
            ax.scatter(*points.T, c = color, s = radius*80);

    def make_empty(self):
        bpy.ops.object.empty_add();
        e = bpy.context.active_object;
        if not hasattr(self, "empty"): #The first created mule will parent all atoms and bonds
            self.empty = self.mule = e;
            self.deselect_all();
            self.select(*self.meshes, e);
            self.set_active(e);
            bpy.ops.object.parent_set(type="OBJECT");
            self.unlink_obj(self.mule)
            self.link_obj(self.mule, self.collection)
        self.mules.append(e);
        e.rotation_mode = "QUATERNION";
        return e;


    #Adding the cylinders
    def cylinder_between(self, x1, y1, z1, x2, y2, z2, r): #this can be made shorter with numpy. But it is more readable this way.
      dx = x2 - x1;
      dy = y2 - y1;
      dz = z2 - z1 ;
      dist = np.sqrt(dx**2 + dy**2 + dz**2);
      bpy.ops.mesh.primitive_cylinder_add(
          radius = r,
          depth = dist,
          location = (dx/2 + x1, dy/2 + y1, dz/2 + z1)
      );
      phi = np.arctan2(dy, dx);
      theta = np.arccos(dz/dist);
      bpy.context.object.rotation_euler[1] = theta;
      bpy.context.object.rotation_euler[2] = phi;
      obj = bpy.context.active_object;
      return obj;

    def centralize(self): # Used for experimenting with molecules. Centers the center of mass
        self.position = self.position - np.array(self.position).mean(axis = 0)
        return self.position;


    @classmethod #Crude method of determing bonds based on their covalent radii. Works well on mol files but not xyz files.
    def detect_bonds(cls, coordinates, radii, ratio = 1.2, constant = None):
        coordinates, radii = np.array(coordinates), np.array(radii);
        pairs = [];
        for i, (c1, r1) in enumerate(zip(coordinates[:-1], radii[:-1])):
            for j, (c2, r2) in enumerate(zip(coordinates[i+1:], radii[i+1:])):
                min_dist = (r1+r2)*ratio if not constant else constant;
                if np.linalg.norm(c2-c1) < min_dist:
                    pairs.append([i, j+i+1]);
        return pairs;

    @classmethod # I got this from ivo. Not sure where these exact numbers come from, but it works well on xyz files.
    def detect_bonds_xyz(cls, atoms):
        #First we set the limits for each kind of bond
        cls.distances = np.full((86, 86), 3.0);
        for i in range(0, 86):
            cls.distances[i][1] = 1.4
            cls.distances[1][i] = 1.4

            if i > 20:
                for j in range(2,20):
                    cls.distances[i][j] = 2.8
                    cls.distances[j][i] = 2.8
            else:
                for j in range(2,20):
                    cls.distances[i][j] = 2.0
                    cls.distances[j][i] = 2.0

        bonds = [];
        for i, a1 in enumerate(atoms[:-1]):
            for j, a2 in enumerate(atoms[i+1:]):
                a1id = cls.data["atomid"][a1.name]
                a2id = cls.data["atomid"][a2.name]
                a1id, a2id = sorted([a1id, a2id]);
                d = np.linalg.norm(a1.position - a2.position);
                if d < cls.distances[a1id, a2id]:
                    bonds.append([i, j+i+1]);
        return bonds;

    def find_closest_indices(self, point, number_elements_per_face = 3): #Can be used to find indices of a specific face of a plane in a molecule. Can later be used to help orient double bonds!
        coordinates = self.position;
        return np.argpartition(np.linalg.norm(coordinates-point,axis=1), number_elements_per_face)[:number_elements_per_face];

    def make_mirror(self, mirror_options, prettify_radii = True): #Makes the mirror that shows up in the animations. Also makes the material if it is not already defined in the scene.
        if "fill_type" not in mirror_options:
            mirror_options["fill_type"] = "NGON";
        if "radius" not in  mirror_options:
            distances = np.linalg.norm(self.position, axis = 1)
            furthest_index = np.argmax(distances)
            if prettify_radii:
                radius = self.get_smaller_radii(self.radius)[furthest_index, np.newaxis]
            else:
                radius = self.radius[furthest_index, np.newaxis]
            mirror_options["radius"] = distances[furthest_index] + 1.5*radius;
        if "vertices" not in mirror_options:
            mirror_options["vertices"] = 32;
        if "SUBSURF" not in mirror_options:
            apply_subsurf = True
        else:
            apply_subsurf = mirror_options["SUBSURF"];
            mirror_options.pop("SUBSURF")
        if not hasattr(self, "mirror"):
            bpy.ops.mesh.primitive_circle_add(**(mirror_options));
            self.mirror = bpy.context.active_object;
            self.mirror.rotation_mode = "QUATERNION";
            if apply_subsurf:
                bpy.ops.object.modifier_add(type="SUBSURF");
                bpy.ops.object.modifier_apply();
        if not bpy.data.materials.get("mirror"):
            m = bpy.data.materials.new(name="mirror");
        m = bpy.data.materials.get("mirror");
        self.mirror.active_material = m;
        m.use_nodes = True;
        if m.node_tree.nodes.get("Principled BSDF"):
            m.node_tree.nodes["Principled BSDF"].inputs[14].default_value = 1.0;
            m.node_tree.nodes["Principled BSDF"].inputs[7].default_value = .1;
            m.node_tree.nodes["Principled BSDF"].inputs[15].default_value = 1;
            m.node_tree.nodes["Principled BSDF"].inputs[0].default_value = [0.52, 0.9, 1, 1];
        m.use_screen_refraction = True;
        m.blend_method = "BLEND"
        bpy.data.scenes["Scene"].eevee.use_ssr = True;
        bpy.data.scenes["Scene"].eevee.use_ssr_refraction = True;
        self.meshes.append(self.mirror);
        self.mirror.name = "Mirror"
        #self.hide(self.mirror);

    def make_rotation_axis(self, options, prettify_radii = True):
        distances = np.linalg.norm(self.position, axis = 1)
        if "depth" not in options:
            furthest_index = np.argmax(distances)
            if prettify_radii:
                radius = self.get_smaller_radii(self.radius)[furthest_index, np.newaxis]
            else:
                radius = self.radius[furthest_index, np.newaxis]
            options["depth"] = (distances[furthest_index] + 1.5*radius)*2;
        if "radius" not in options:
            options["radius"] = 0.025*(distances.max()**(1/1.5) if distances.max()**(1/2)>1 else 1);
        bpy.ops.mesh.primitive_cylinder_add(**options);
        self.rotation_axis = bpy.context.active_object;
        self.rotation_axis.rotation_mode = "QUATERNION";
        self.meshes.append(self.rotation_axis)
        self.rotation_axis.name = "Rotation_axis"
        # self.hide(self.rotation_axis);


    def rotation_to(self, v2, v1 = [0, 0, 1]):
        """
        Rotation from v1 to v2 in quaternion mode 
        """
        v1, v2 = np.array(v1)/np.linalg.norm(v1), np.array(v2)/np.linalg.norm(v2);
        axis = np.cross(v1, v2);
        angle = np.arccos(v1.dot(v2));
        return mathutils.Quaternion(axis, angle);

    def set_ending(self, tf):
        """
            Sets the ending of the recording at frame tf"""
        bpy.context.scene.frame_end = tf;

    #For the animation secion below, note that the animations follow the following scheme
    ## time ->   0    0   sp   1(sp+tt) 1(sp+tt)+sp 2(sp+tt)...
    ## interval - > 0   sp  tt      sp        tt     ...

    #Animation durations
    ## Rotation and reflection 3*(sp + tt)
    ## Improper_rotation 5*(sp + tt)
    ## identity (sp + tt)
    ## inversion 2*(sp + tt)


    def animate_rotation(self, t0, normal, angle, orbitals = "pz"):
        """
        Performs the appropriate rotations and scalings to make a reflection animation.
        The times can be tweaked through short_pause and transition.
        returns the time at which the animation ends."""
        #Creating the carrier of the molecule
        self.deselect_all();
        parent_mule = self.make_empty();
        parent_mule.rotation_quaternion = self.rotation_to(normal);
        self.set_parent(parent_mule, self.mules[-2]); #Note that self.mules[-1] will contain parent_mule

        tt = self.transition;
        sp = self.short_pause;
        tf = t0 + 3*(tt + sp);

        #animating the cylinder that shows the axis of rotation
        self.rotation_axis.rotation_quaternion = parent_mule.rotation_quaternion.copy();
        self.rotation_axis.keyframe_insert(data_path = "rotation_quaternion", frame = t0 + sp);
        self.rotation_axis.keyframe_insert(data_path = "rotation_quaternion", frame = tf);

        self.add_transition("scale", self.rotation_axis, t0 + sp, tt, [0, 0, 0], [1, 1, 1])
        self.add_transition("scale", self.rotation_axis, tf - tt, tt, [1, 1, 1], [0, 0, 0]);
        
        #Animating the actual rotation of the carrier
        rot_init = parent_mule.rotation_quaternion.copy();
        rot = rot_init.copy()
        rot.rotate(mathutils.Quaternion(normal, angle));
        self.add_transition("rotation_quaternion", parent_mule, t0+2*sp+tt, tt, rot_init, rot);
        self.add_transition("rotation_quaternion", parent_mule, tf-tt, tt, rot, rot_init);

        if orbitals:
            mat = np.array(mathutils.Matrix.Rotation(angle, 3, normal));
            in_place = self.find_static_orbitals(mat)
            scales = np.abs(self.find_final_projections(mat, orb = orbitals))[self.find_static_atoms(mat).astype(bool)]
            meshes_in_place = [self.orbital_meshes[i] for i, stayed in enumerate(in_place) if stayed]
            fading_meshes = [mesh for mesh in self.orbital_meshes if mesh not in meshes_in_place and mesh]
            
            t2 = int(tt/2)
            for i, mesh in enumerate(meshes_in_place):
                #Making them shine
                self.add_material_transition("emission", mesh, t0 + t2, t2, (0, 0, 0, 1), (.2, .2, .2, 1))
                self.add_material_transition("emission", mesh, tf - t2, t2,(.2, .2, .2, 1), (0, 0, 0, 1))

                #Making them SMOL
                self.add_transition("scale", mesh, t0 + t2, t2, [1]*3, [scales[i]]*3)
                self.add_transition("scale", mesh, tf - t2, t2, [scales[i]]*3, [1]*3)
                
            for mesh in fading_meshes:
                #Initial fade out
                self.add_material_transition("alpha", mesh, t0 + t2, t2, 1, .5)
                self.add_material_transition("alpha", mesh, t0 + tt + sp*2, t2, .5, 0)
                self.add_material_transition("alpha", mesh, tf - t2, t2, 0, 1)

        self.set_ending(tf);
        return tf; #Returns the end of this animation

            

    def animate_reflection(self, t0, normal, orbitals = "pz"):
        """
        Performs the appropriate rotations and scalings to make a reflection animation.
        The times can be tweaked through short_pause and transition.
        returns the time at which the animation ends."""
        #Creating the carrier of the molecule
        self.deselect_all();
        parent_mule = self.make_empty();
        parent_mule.rotation_quaternion = self.rotation_to(normal);
        self.set_parent(parent_mule, self.mules[-2]); #Note that self.mules[-1] will contain parent_mule

        tt = self.transition;
        sp = self.short_pause;
        tf = t0 + 3*(tt + sp);

        #animating the cylinder that shows the axis of rotation
        self.mirror.rotation_quaternion = parent_mule.rotation_quaternion.copy();
        self.mirror.keyframe_insert(data_path = "rotation_quaternion", frame = t0 + sp);
        self.mirror.keyframe_insert(data_path = "rotation_quaternion", frame = tf);

        self.add_transition("scale", self.mirror, t0 + sp, tt, [0, 0, 0], [1, 1, 1])
        self.add_transition("scale", self.mirror, tf - tt, tt, [1, 1, 1], [0, 0, 0]);

        #Animating the actual rotation of the carrier
        scale_init = parent_mule.scale.copy();
        scale_final = np.array(scale_init)*[1, 1, -1];
        self.add_transition("scale", parent_mule, t0+2*sp+tt, tt, scale_init, scale_final);
        self.add_transition("scale", parent_mule, tf-tt, tt, scale_final, scale_init);

        if orbitals:
            mat = np.array(mathutils.Matrix.Scale(-1, 3, normal));
            in_place = self.find_static_orbitals(mat)
            scales = np.abs(self.find_final_projections(mat, orb = orbitals))[self.find_static_atoms(mat).astype(bool)]
            meshes_in_place = [self.orbital_meshes[i] for i, stayed in enumerate(in_place) if stayed]
            fading_meshes = [mesh for mesh in self.orbital_meshes if mesh not in meshes_in_place and mesh]

            t2 = int(tt/2)
            for i, mesh in enumerate(meshes_in_place):
                #Making them shine
                self.add_material_transition("emission", mesh, t0 + t2, t2, (0, 0, 0, 1), (.2, .2, .2, 1))
                self.add_material_transition("emission", mesh, tf - t2, t2,(.2, .2, .2, 1), (0, 0, 0, 1))

                #Making them SMOL
                self.add_transition("scale", mesh, t0 + t2, t2, [1]*3, [scales[i]]*3)
                self.add_transition("scale", mesh, tf - t2, t2, [scales[i]]*3, [1]*3)
                
            for mesh in fading_meshes:
                #Initial fade out
                self.add_material_transition("alpha", mesh, t0 + t2, t2, 1, .5)
                self.add_material_transition("alpha", mesh, t0 + tt + sp*2, t2, .5, 0)
                self.add_material_transition("alpha", mesh, tf - t2, t2, 0, 1)

        self.set_ending(tf);
        return tf; #Returns the end of this animation


    def animate_improper_rotation(self,t0, normal, angle, orbitals = "pz"):
        """
        Performs the appropriate rotations and scalings to make a reflection animation.
        The times can be tweaked through short_pause and transition.
        returns the time at which the animation ends."""
        #Creating the carrier of the molecule
        self.deselect_all();
        parent_mule = self.make_empty();
        parent_mule.rotation_quaternion = self.rotation_to(normal);
        self.set_parent(parent_mule, self.mules[-2]); #Note that self.mules[-1] will contain parent_mule

        tt = self.transition;
        sp = self.short_pause;
        tf = t0 + 5*(tt + sp);

        #animating the cylinder that shows the axis of rotation
        for o in [self.rotation_axis, self.mirror]:
            o.rotation_quaternion = parent_mule.rotation_quaternion.copy();
            o.keyframe_insert(data_path = "rotation_quaternion", frame = t0 + sp);
            o.keyframe_insert(data_path = "rotation_quaternion", frame = tf);

        self.add_transition("scale", self.rotation_axis, t0 + sp, tt, [0, 0, 0], [1, 1, 1])
        self.add_transition("scale", self.rotation_axis, tf - tt, tt, [1, 1, 1], [0, 0, 0]);

        self.add_transition("scale", self.mirror, t0 + sp + 2*(sp+tt), tt, [0, 0, 0], [1, 1, 1])
        self.add_transition("scale", self.mirror, tf - tt, tt, [1, 1, 1], [0, 0, 0]);

        #Animating the actual rotation of the carrier
        rot_init = parent_mule.rotation_quaternion.copy();
        rot = rot_init.copy();
        rot.rotate(mathutils.Quaternion(normal, angle));
        self.add_transition("rotation_quaternion", parent_mule, t0+1*(sp+tt)+sp, tt, rot_init, rot);
        self.add_transition("rotation_quaternion", parent_mule, tf-tt, tt, rot, rot_init);

        #Animating the actual rotation of the carrier
        scale_init = parent_mule.scale.copy();
        scale_final = np.array(scale_init)*[1, 1, -1];
        self.add_transition("scale", parent_mule, t0 + sp + 3*(sp+tt), tt, scale_init, scale_final);
        self.add_transition("scale", parent_mule, tf-tt, tt, scale_final, scale_init);

        if orbitals:
            mat = np.array(mathutils.Matrix.Rotation(angle, 3, normal));
            in_place = self.find_static_orbitals(mat)
            scales = np.abs(self.find_final_projections(mat, orb = orbitals))[self.find_static_atoms(mat).astype(bool)]
            meshes_in_place = [self.orbital_meshes[i] for i, stayed in enumerate(in_place) if stayed]
            fading_meshes = [mesh for mesh in self.orbital_meshes if mesh not in meshes_in_place and mesh]

            t2 = int(tt/2)
            for i, mesh in enumerate(meshes_in_place):
                #Making them shine
                self.add_material_transition("emission", mesh, t0 + t2, t2, (0, 0, 0, 1), (.2, .2, .2, 1))
                self.add_material_transition("emission", mesh, tf - t2, t2,(.2, .2, .2, 1), (0, 0, 0, 1))

                #Making them SMOL
                self.add_transition("scale", mesh, t0 + t2, t2, [1]*3, [scales[i]]*3)
                self.add_transition("scale", mesh, tf - t2, t2, [scales[i]]*3, [1]*3)
                
            for mesh in fading_meshes:
                #Initial fade out
                self.add_material_transition("alpha", mesh, t0 + t2, t2, 1, .5)
                self.add_material_transition("alpha", mesh, t0 + tt + sp*2, t2, .5, 0)
                self.add_material_transition("alpha", mesh, tf - t2, t2, 0, 1)
            fading_meshes_rotation = fading_meshes

        if orbitals:
            mat = np.array(mathutils.Matrix.Scale(-1, 3, normal)@mathutils.Matrix.Rotation(angle, 3, normal));
            in_place = self.find_static_orbitals(mat)
            scales = np.abs(self.find_final_projections(mat, orb = orbitals))[self.find_static_atoms(mat).astype(bool)]
            fading_meshes = [mesh for mesh in self.orbital_meshes if mesh not in meshes_in_place and mesh not in fading_meshes_rotation and mesh]

            t2 = int(tt/2)
            t0 += 3*sp + 2*tt #For the rotation
            for mesh in fading_meshes:
                #Initial fade out
                self.add_material_transition("alpha", mesh, t0 + t2, t2, 1, .5)
                self.add_material_transition("alpha", mesh, t0 + tt + sp*2, t2, .5, 0)
                self.add_material_transition("alpha", mesh, tf - t2, t2, 0, 1)
            t0 -= 3*sp + 2*tt

        self.set_ending(tf);
        return tf; #Returns the end of this animation


    def animate_identity(self, t0, orbitals = "pz"):
        tf = t0 + self.transition + self.short_pause;
        #The step below just hides the mirror in case the molecule being rendered does not have any symmetry operations that use the mirror
        for o in (self.mirror, self.rotation_axis):
            o.scale = mathutils.Vector([0, 0, 0]);
            o.keyframe_insert(data_path = "scale", frame = t0);

        t2 = int(self.transition/3)
        sp = self.short_pause
        meshes = [om for om in self.orbital_meshes if om]; #Some meshes may be set to None
        for i, mesh in enumerate(meshes):
            #Making them shine
            self.add_material_transition("emission", mesh, t0 + sp, t2, (0, 0, 0, 1), (.2, .2, .2, 1))
            self.add_material_transition("emission", mesh, tf - 2*t2, t2,(.2, .2, .2, 1), (0, 0, 0, 1))
        self.set_ending(tf);
        return tf;

    def animate_inversion(self, t0, orbitals = "pz"):
        sp, tt = self.short_pause, self.transition;
        tf = t0 + 2*(sp + tt);

        #Unlike in the other transformations, we do not need to make a new mule. Mule 0 does not have any inclination, so we can just invert it
        mule = self.empty;
        scale_init = mule.scale.copy();
        scale_final = np.array(scale_init)*-1;
        self.add_transition("scale", mule, t0 + sp, tt, scale_init, scale_final);
        self.add_transition("scale", mule, tf - tt, tt, scale_final, scale_init);


        if orbitals:
            mat = -np.eye(3);
            in_place = self.find_static_orbitals(mat)
            scales = np.abs(self.find_final_projections(mat, orb = orbitals))[self.find_static_atoms(mat).astype(bool)]
            meshes_in_place = [self.orbital_meshes[i] for i, stayed in enumerate(in_place) if stayed]
            fading_meshes = [mesh for mesh in self.orbital_meshes if mesh not in meshes_in_place and mesh]

            t2 = int(tt/2)
            for i, mesh in enumerate(meshes_in_place):
                #Making them shine
                self.add_material_transition("emission", mesh, t0 + t2, t2, (0, 0, 0, 1), (.2, .2, .2, 1))
                self.add_material_transition("emission", mesh, tf - t2, t2,(.2, .2, .2, 1), (0, 0, 0, 1))

                #Making them SMOL
                self.add_transition("scale", mesh, t0 + t2, t2, [1]*3, [scales[i]]*3)
                self.add_transition("scale", mesh, tf - t2, t2, [scales[i]]*3, [1]*3)
                
            for mesh in fading_meshes:
                #Initial fade out
                self.add_material_transition("alpha", mesh, t0 + t2, t2, 1, 0)
                self.add_material_transition("alpha", mesh, tf - t2, t2, 0, 1)
        self.set_ending(tf);
        return tf;

    def setup_dir(self, name):
        if not os.path.isdir(name):
            os.makedirs(name);
        return name;

    def animate_properties(self, cc_list, normals, angles = [], target_directory = "Animation_files",t0 = 0, orbitals = "pz"):
        """
            Angles must be supplied as a list. Transformations which do not use angles should have a None on the list OR a 0
            If angles are not supplied, the length of the normals is used instead.
            """
        if len(angles) == 0:
            angles = self.angles_from_normals(normals);
        starts = [t0]; #Starting times of each animation
        starts_directories = []; #Name of each directory corresponding to a "start"
        directory = os.path.join(os.getcwd(),target_directory); #All the animations will be stored in directories inside this directory
        for ci, cc in enumerate(cc_list): #For each conjugacy class we make a directory
            new_dir = os.path.join(directory, cc);
            pattern = re.compile(r"([A-Z]|i|sig)");
            operation = pattern.findall(cc)[0];
            func = {
                "E": self.animate_identity,
                "C": self.animate_rotation,
                "i": self.animate_inversion,
                "S": self.animate_improper_rotation,
                "sig": self.animate_reflection}[operation]; #For each operatio in the conjugacy class we setup the animation and make the directory
            print(operation)
            if operation == "i" or operation == "E":
                d = os.path.join(new_dir,cc);
                starts_directories.append(d);
                t0 = func(t0, orbitals); #Note how the dimensions of e and i are still then same as the other transformations
                starts.append(t0);
            else:
                for ni, n in enumerate(normals[ci]):
                    d = os.path.join(new_dir, cc + "_" + str(ni).zfill(2));
                    d = PointGroup.normal_to_directory(d); #Removes all the primes from the directory name
                    starts_directories.append(d);
                    if operation == "sig":
                        t0 = func(t0, n, orbitals);
                    else:
                        t0 = func(t0, n, angles[ci], orbitals)
                    starts.append(t0);
        return starts, starts_directories; #Now we can just render into starts_directories

    @staticmethod # I also got this function from Ivo
    def write_xyz(names, vertices, outfile):
        # output results
        f = open(outfile, 'w')
        f.write("%i\n\n" % len(names))
        for n, v in zip(names, vertices):
            f.write('%s  %12.6f  %12.6f  %12.6f\n' % (n, *v));
        f.close()

    

